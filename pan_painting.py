# -*- coding: cp936 -*-
'''
#我女儿喜欢看小马宝莉，也喜欢给简笔画涂色彩
#我这个脚本就是给她写的， 随意找张动画片屏幕截图， 就可以制成简笔画了
#用法python pan_painting.py  你的图片 例如 python pan_painting.py  time.jpg
#此脚本是windows环境python 2.7+opencv3.2版本的
#需要提前安装speech模块， 安装方法pip install speech
'''
print (__doc__)
import cv2
#导入cv2这个module模块
import numpy as np
#导入numpy这个计算用的模块
#import argparse
#导入参数模块
import sys
#import speech
#加载语音模块
def nothing(x):
    pass
#自定义一个nothing的模块， 后面的trackbar动作会用到

#speech.say("现在开始")
#说话， 代表开始
#ap = argparse.ArgumentParser()
#ap.add_argument("-i", "--image", required=True,help="path to the input image")
#提示需要加入图片的提示
#args = vars(ap.parse_args())
#这个就是会代入程序的图片名称参数值

# load the image and resize it to a smaller factor so that
# the shapes can be approximated better
im = cv2.imread(sys.argv[1])
#读取命令中代入的图片名称
kernel = np.ones((5,5),np.uint8)
#im=cv2.imread('time.jpg',0)

cv2.imshow('raw',im)
gray=cv2.cvtColor(im,6)
#显示这个图片
cv2.namedWindow('edge',0)
#创建一个名字叫edge的新窗口，用来显示加工后的效果图， 0的意思是， 窗口可伸缩
cv2.createTrackbar('thrs1', 'edge', 203, 255, nothing)
#创建一个叫做thrs1的滑动条，默认值是127， 在0-255的范围内， 手动调整阀值范围， 调用上面的nothing模块，其实相当于什么都没做，这是格式要求的。
while(True):
#循环，为什么要循环？因为手动调整阀值，效果跟着变，不停地调整，不停的变，所以要循环
    thrs1 = cv2.getTrackbarPos('thrs1', 'edge')
    #print thrs1
    #阀值thrs1等于edge窗口中thrs1的值
    ret, thresh=cv2.threshold(gray,thrs1,255,cv2.THRESH_BINARY_INV)
    #
    #黑白差值化,标准取自滑动条上的阀值
    #cv2.imshow('thresh',thresh)
    #显示黑白差值图
    edges = cv2.Canny(thresh,0,255,3)
    #这个是边缘图，黑底，白线
    edges_INV =cv2.bitwise_not(edges)
    #取反， 白底，黑线
    #erosion = cv2.erode(edges1,kernel,iterations = 1)
    #dilation = cv2.dilate(edges1,kernel,iterations = 1)
    #cv2.imwrite(sys.argv[1]+'.jpg',edges_INV)
    #写入源文件， 替换掉原图
    cv2.imshow('edge',edges_INV)

    #显示新图
    cv2.waitKey(50)
#cv2.imshow('erosion',erosion)
#cv2.imshow('dilation',dilation)
#speech.say("转换结束")
#语音提示， 提示程序完成
#cv2.waitKey(0)
#按任意键退出

